## 题库
1. 剑指offer题库：`https://www.acwing.com/problem/search/2/?csrfmiddlewaretoken=Lfru0f60yxMyo7cb5M0yhKIVmdNnVgliSa5L8c7rB5MeFmDNt3QVwQ149XZ8p7E3&search_content=%E5%89%91%E6%8C%87offer`
2. 剑指offer题解：`https://blog.csdn.net/FlushHip/column/info/19892`
3. 剑指offer视频：`https://www.bilibili.com/video/av39556817`

## 时间复杂度
```
    认识时间复杂度
        常数时间的操作：一个操作如果和数据量没有关系，每次都是固定时间内完成的操作，叫做常数操作。

    时间复杂度为一个算法流程中，常数操作数量的指标。常用O（读作big O）来表示。具体来说，在常数操作数量的表达式中，只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分，如果记为f(N)，那么时间复杂度为O(f(N))。

    评价一个算法流程的好坏，先看时间复杂度的指标，然后再分析不同数据样本下的实际运行时间，也就是常数项时间。
```
例1： 一个简单的理解时间复杂度的例子：一个有序数组A，另一个无序数组B，请打印B中的所有不在A中的数，A数组长度为N，B数组长度为M。
```
    算法流程1：对于数组B中的每一个数，都在A中通过遍历的方式找一下；
    算法流程2：对于数组B中的每一个数，都在A中通过二分的方式找一下；
    算法流程3：先把数组B排序，然后用类似外排的方式打印所有在A中出现的数；
    三个流程，三种时间复杂度的表达... 如何分析好坏？
```

## 对数器
1. 对数器的概念和使用
    ```
    0，有一个你想要测的方法a，
    1，实现一个绝对正确但是复杂度不好的方法b，
    2，实现一个随机样本产生器
    3，实现比对的方法
    4，把方法a和方法b比对很多次来验证方法a是否正确。
    5，如果有一个样本使得比对出错，打印样本分析是哪个方法出错
    6，当样本数量很多时比对测试依然正确，可以确定方法a已经正确。
    ```
2. 代码实现
    ```
    //  生出长度随机的数组
        // for test
        public static int[] generateRandomArray(int maxSize, int maxValue) {
            int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
            for (int i = 0; i < arr.length; i++) {
                arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
            }
            return arr;
        }
    //  比较两个数组
        public static boolean isEqual(int[] arr1, int[] arr2) {
            if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
                return false;
            }
            if (arr1 == null && arr2 == null) {
                return true;
            }
            if (arr1.length != arr2.length) {
                return false;
            }
            for (int i = 0; i < arr1.length; i++) {
                if (arr1[i] != arr2[i]) {
                    return false;
                }
            }
            return true;
        }
    //一个绝对正确的方法
        public static void comparator(int[] arr) {
            Arrays.sort(arr);
        }

    //拷贝数组
        public static int[] copyArray(int[] arr) {
            if (arr == null) {
                return null;
            }
            int[] res = new int[arr.length];
            for (int i = 0; i < arr.length; i++) {
                res[i] = arr[i];
            }
            return res;
        }

    //  对数器
    public static void main(String[] args) {
            int testTime = 500000;
                //数组长度
            int maxSize = 100;
                //数在0-100之间
            int maxValue = 100;
            boolean succeed = true;
            for (int i = 0; i < testTime; i++) {
                int[] arr1 = generateRandomArray(maxSize, maxValue);
                int[] arr2 = copyArray(arr1);
                bubbleSort(arr1);
                comparator(arr2);
                if (!isEqual(arr1, arr2)) {
                    succeed = false;
                    break;
                }
            }
            System.out.println(succeed ? "Nice!" : "Fucking fucked!");

            int[] arr = generateRandomArray(maxSize, maxValue);
            printArray(arr);
            bubbleSort(arr);
            printArray(arr);
        }
    ```

## 排序
### 冒泡排序
```
    冒泡排序细节的讲解与复杂度分析
    时间复杂度O(N^2)，额外空间复杂度O(1)

    思路：每次找最大的数放在后面，范围不断缩小

    代码：
            // 时间复杂度O(N^2)，额外空间复杂度O(1)
            public class BubbleSort {
                public static void bubblesort(int [] arr){
                    for(int i = arr.length - 1;i > 0 ;i --){
                        for(int j = 0; j < i;j++){
                            if(arr[j] > arr[j+1]){
                                swap(arr, j, j+1);
                            }
                        }
                    }
                }
                public static void swap(int[] arr, int i, int j){
                    int temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                }
                public static void main(String [] args){
                    int[] arr = {4 , 2 , 3 , 1};
                    bubblesort(arr);
                    System.out.println(Arrays.toString(arr));
                }
            }
```
### 选择排序
```
    选择排序的细节讲解与复杂度分析
    时间复杂度O(N^2)，额外空间复杂度O(1)

    思路：0到n-1上最小的数和0位置上交换，1到n-1上最小的数和1位置上交换，以此类推

    代码：
            // 时间复杂度O(N^2)额外空间复杂度O(1)
            public class SelectionSort {
                public static void selectsort(int[] arr){
                    for(int i = 0; i < arr.length; i++){
                        int minIndex = i;
                        for(int j = i + 1; j <arr.length; j ++ ){
                            minIndex = arr[j] < arr[minIndex] ? j : minIndex;
                        }
                        swap(arr, i, minIndex);
                    }
                }
                public static void swap(int[] arr, int i, int j){
                    int temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                }
                public static void main(String [] args){
                    int[] arr = {3, 5, 2, 4, 1};
                    selectsort(arr);
                    System.out.println(Arrays.toString(arr));
                }

            }
```
### 插入排序
```
    插入排序的细节讲解与复杂度分析
    时间复杂度O(N^2)，额外空间复杂度O(1)

    思路：就像自己手里攥了好多牌，攥的牌是已经排好的，但是新抓了一张牌，这张牌就看能滑到哪个位置上插进去

    代码：
            //    时间复杂度O(N^2)，额外空间复杂度O(1)
            public class InsertSort {
                public static void insertsort(int[] arr){
                    for(int i = 1; i < arr.length; i++){
                        for(int j = i - 1;j >= 0 && arr[j+1] < arr[j]; j--){
                            swap(arr, j, j+1);
                        }
                    }
                }
                public static void swap(int[] arr, int i, int j){
                    int temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                }
                public static void main(String [] args){
                    int[] arr = {5, 3, 2, 4, 1};
                    insertsort(arr);
                    System.out.println(Arrays.toString(arr));
                }
            }
```
### 归并排序
#### master公式
```
    剖析递归行为和递归行为时间复杂度的估算
    一个递归行为的例子
    master公式的使用
    T(N) = a*T(N/b) + O(N^d)
    1) log(b,a) > d -> 复杂度为O(N^log(b,a))
    2) log(b,a) = d -> 复杂度为O(N^d * logN)
    3) log(b,a) < d -> 复杂度为O(N^d)
    补充阅读：www.gocalf.com/blog/algorithm-complexity-and-mastertheorem.html

    master适用范围：所有子过程规模必须一样
```
#### 归并排序
```
    归并排序的细节讲解与复杂度分析
    时间复杂度O(N*logN)，额外空间复杂度O(N)

    归并排序快的实质：没有浪费比较，充分利用了每次比较，因为冒泡排序等排序方法，每次比较只搞定了一个数，浪费了很多比较

    代码：
        public class Merge {
            public static void mergesort(int[] arr){
                if(arr == null || arr.length < 2){
                    return;
                }
                mergesort(arr, 0, arr.length-1);
            }
            public static void mergesort(int[] arr, int l, int r){
                    //递归函数出口
                if(l == r){
                    return;
                }
                int mid = l + ((r - l) >> 1);
                    //左边排好序，右边排好序
                mergesort(arr, l, mid);
                mergesort(arr, mid + 1, r);
                    //利用外排将左右排好序的数组放在一个新的数组中，然后拷贝给原数组
                merge(arr, l, r, mid);
            }
            public static void merge(int arr[], int l, int r, int m){
                int i = 0;
                int p1 = l;
                int p2 = m+1;
                    //生成辅助数组
                int[] help = new int[r - l + 1];
                while(p1 <= m && p2 <= r){
                    help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
                }
                while(p1 <= m){
                    help[i++] = arr[p1++];
                }
                while(p2 <= r){
                    help[i++] = arr[p2++];
                }
                for(int j= 0; j < help.length; j ++){
                    arr[l + j] = help[j];
                }
            }
            public static void swap(int[] arr, int i, int j){
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
            public static void main(String [] args){
                int[] arr = {4 , 2 , 1, 3};
                mergesort(arr);
                System.out.println(Arrays.toString(arr));
            }
        }
```
#### 小和问题和逆序对问题
1. 小和问题：在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。
    ```
    例子：
            [1,3,4,2,5]
            1左边比1小的数，没有；
            3左边比3小的数，1；
            4左边比4小的数，1、3；
            2左边比2小的数，1；
            5左边比5小的数，1、3、4、2；
        所以小和为1+1+3+1+1+3+4+2=16

    思路：
        我在每次merge过程中，先将产生的小和存起来，然后将当前部分进行排序，再后续炸出小和
        先边排序边求左部分小和，然后边排序边求右部分小和，然后整体边排序边求小和
        排序和求小和过程：谁小谁后移动，若是左部分小，res += (右面当前位置往后元素的个数) * 左部分当前位的值，若是右半部分小，不产生小和，不做计算，指针后移

    代码：
        public class SmallSum {
            public static void mergesort(int[] arr){
                if (arr == null|| arr.length < 2) {
                    return;
                }
                System.out.println(mergesort(arr, 0, arr.length - 1));
            }
            public static int mergesort(int[] arr, int l, int r){
                if(l == r){
                    return 0;
                }
                /*不使用(l + r)/2，而是使用l + ((r - l)>>1)，可以防止溢出，而且位运算比算术运算快很多
                注意右移必须加括号，要不会报错
                */
                int mid = l + ((r - l)>>1);
                return mergesort(arr, l, mid) + mergesort(arr, mid + 1, r) + merge(arr, l, mid, r);
            }
            public static int merge(int[] arr, int l, int m, int r){
                int p1 = l;
                int p2 = m + 1;
                int res = 0;
                int i= 0;
                /*这里的长度也要根据传进来的数判断，不能生成随便长度的数组*/
                int[] help = new int[r - l + 1];
                while(p1 <= m && p2 <= r){
                res += arr[p2] > arr[p1] ? arr[p1] * ( r - p2 + 1 ) : 0;
                help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
                }
                while(p1<=m){
                    help[i++] = arr[p1++];
                }
                while(p2 <= r){
                    help[i++] = arr[p2++];
                }
                /*这里注意是help.length和arr[l+j]，不能写j，万一参数是2或者3什么的，这里的差别就很明显了，因为每次传进来的参数不一样，长度就有可能不一样，*/
                for(int j =0;j < help.length;j++){
                    arr[l+j] = help[j];
                }
                return res;
            }
            public static void main(String [] args){
                int[] arr = {2, 3, 1, 4};
                mergesort(arr);
            }
        }

    ```
2. 逆序对问题
    ```
        在一个数组中，左边的数如果比右边的数大，则折两个数构成一个逆序对，请打印所有逆序对。
    ```

### 快排
1. 
    + 例题1
        ```
        给定一个数组arr，和一个数num，请把小于等于num的数放在数
        组的左边，大于num的数放在数组的右边。

        要求额外空间复杂度O(1)，时间复杂度O(N)

        ```
    + 例题2:（荷兰国旗问题）
        ```
        问题：给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边。

        要求：额外空间复杂度O(1)，时间复杂度O(N)

        思路：
            三个变量
            less: 存储小于区域的最后一个位置
            more：存储大于区域的第一个位置
            cur：当前位置
            当 当前位置的数小于num，那么就将cur指向的数和小于区域下一个位置交换，然后less ++(小于区域扩大一个位置)， cur++(指针向后移动一位)
            当 当前位置的数等于num，什么都不做，cur++(cur向后移动一位)，继续判断，
            当 当前位置的数大于num，将cur指向的数和大于区域的前一个位置交换，然后more --，然后cur不变，继续判断我换过来的这个数，大于小于还是等于num

        代码： 
            public class NetherlandsFlag {
                public static void partition(int[] arr, int num ,int L, int R){
                    int less = L -1;
                    int more = R + 1;
                    int cur = L;
                    while(cur < more){
                        if(arr[cur] < num){
                            swap(arr, cur++, ++less);
                        }
                        else if(arr[cur] > num){
                            swap(arr, cur, --more);
                        }
                        else{
                            cur ++;
                        }
                    }
                }
                public static void swap(int[] arr, int i,int j){
                    int temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                }
                public static void main(String [] args){
                    int num = 5;
                    int[] arr = {10, 9, 8, 5, 7, 6, 5, 4, 3, 2, 1};
                    partition(arr, num, 0, 10);
                    System.out.println(Arrays.toString(arr));
                }
            }

        ```
2. 经典快排
    + 思路：就是在荷兰国旗的问题上，将大于区域最后一个数(num)一开始就不让它参与遍历，最后再让它归位
        ```
            将最后一个位置的数作为num，我每次都将小于等于num的放在左边，大于num的数放在右面，
            我将最后一位的数也就是等于num的数放在more中，
            最后，将最后一位上的数和more交换，
            因为more位置上的数一定是大于num中最靠左位置的，然后我将more和最后一位上的数，也就是等于num的数进行交换
            此时就完成了所有的数小于靠左，大于靠右，等于靠中间
        ```
    + 代码：见随机快排
    + 存在的问题：总拿最后一个数去划分是和我的数据状况有关系的，
        - 比如：[1,2,3,4,5,6],每次我都拿最后一个数去划分，每次也就只能搞定一个数，所以，时间复杂度就是O(N^2)，
        - 又比如我每次都正正好好打在中间，那么我的时间复杂度利用master公式得到就是O(N*logN)
3. 随机快排
    ```
    随机快速排序的细节和复杂度分析可以用荷兰国旗问题来改进快速排序时间复杂度O(N*logN)，额外空间复杂度O(logN)

    解释额外空间复杂度：使用额外空间这个事是一个概率，如果每次都打到中间，那么额外空间复杂度就是O(logN)，但是数据状况是不确定的，所以长期期望是O(logN)

    思路：     
        每次随机选择一个数，把它和最后一个位置上的数进行交换，然后拿这个随机的数做这样的划分
    注意：工程上快排是非递归版本的

    代码：
        public class QuickSort {
            public static void quicksort(int[] arr){
                if(arr == null || arr.length < 2){
                    return ;
                }
                quicksort(arr, 0, arr.length-1);
            }
            public static void quicksort(int[] arr, int l, int r){
                if(l < r){
                    int[] p = partition(arr, l, r);
                    quicksort(arr, l, p[0] - 1);
                    quicksort(arr, p[1] + 1, r);
                }
            }
            public static int[] partition(int[] arr, int l, int r){
                swap(arr , (int)(Math.random() * (r - l + 1)) + l, r);
                int less = l - 1;
                int more = r;
                int cur = l;
                while(cur < more){
                    if(arr[cur] < arr[r]){
                        swap(arr , ++less, cur++);
                    }
                    else if(arr[cur] > arr[r]){
                        swap(arr , --more, cur);
                    }
                    else{
                        cur ++;
                    }
                }
                swap(arr, r, more);
                return new int[]{ less + 1, more};
            }
            public static void swap(int[] arr, int i, int j){
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
            public static void main(String[] args){
                int[] arr = {3, 6, 2, 5, 4, 3, 2};
                quicksort(arr);
                System.out.println(Arrays.toString(arr));
            }
        }

    ```
4. 补充：有些算法我想绕开它本身的数据状况怎么办
    + 我用随机这个东西打乱你的数据状况
    + 哈希函数打乱

### 堆排

#### 基础概念
1. 二叉树两个概念
    + 完全二叉树
    + 满二叉树
2. 堆的概念(堆就是完全二叉树)
    + 大根堆：在完全二叉树中任何一个子树的最大值就是这个子树的头部
        - 时间复杂度为log1 + log2 +  ..... + log(N-1) = O(N),因为，每一个结点调整建立大根堆的过程，就是此时形成完全二叉树的高度，完全二叉树的高度就是logN
    + 小根堆：在完全二叉树中任何一个子树的最小值就是这个子树的头部
3. 数组对应脑海中的逻辑上的完全二叉树
    ```
    i   
        左孩子： 2 * i + 1
        右孩子： 2 * i + 2
        父节点： (i - 1) / 2
    ```
4. 
    + heapInsert(建立大根堆)，当新添值后，不断往上走的过程
    + heapify，当我某个值变小了，我要经历往下调整,小值往下扎，也是建立大根堆的过程
5. 例题1：我有几个机制，就是每次都向外吐一个数，要求，当我在求出任意时刻的中位数
    ```
    思路：我建立两个堆，一个大根堆，一个小根堆，每当新吐出来一个数的时候，我就将当前数和大
        根堆的堆顶比较，如果当前数小于等于大根堆堆顶，我才进去大根堆，
        然后当大根堆和小根堆中数的个数差值大于1的话
        (因为我要保证两个堆数量都趋近于n/2)，我将数量多的那个堆的堆顶弹到另
        个堆中，重新形成大根堆或者小根堆，
        这样就保证了，较小的n/2在大根堆中，较大的n/2在小根堆中
        这样就可以随时拿到中位数
    利用堆的好处：每次我调整大根堆或者小根堆的代价只是O(logN)的，很低的复杂度

    ```

#### 堆排
1. 思路:
一个数组让它整体都形成一个大根堆，然后把最后一个位置和堆顶位置做交换，就相当于我形成一个大根堆，我每次都把这个大根堆的最后一个位置和头部交换，头部换回来之后，就把它从堆上减掉，然后我再调整缩小范围的这个堆，重新调整成一个大根堆，直到我堆的大小剪完，所有的最大值依次被填在了倒数第一，倒数第二......最后填到0位置，整个数组排完序
2. 特点：这个结构已经形成了大小为n，进来一个数是代价O(logN)能够搞定的
3. 代码：
    ```
            package myP;
            import java.util.Arrays;

            public class HeapSort {
                public static void heapsort(int[] arr){
                    if(arr == null || arr.length < 2){
                        return ;
                    }
                    /*建立大根堆的过程·*/
                    for(int i = 0; i < arr.length; i++){
                        heapInsert(arr , i);
                    }
                    int heapsize = arr.length;
                    /*将大根堆的头部与末尾的数进行交换，然后将换来的数一点一点往下沉，找到合适的位置，重新建立大根堆heapify*/
                    swap(arr, 0, --heapsize);
                    while(heapsize > 0){
                        heapify(arr, 0, heapsize);
                        swap(arr, 0, --heapsize);
                    }
                }
                /*小值往下扎*/
                public static void heapify(int[] arr, int index, int heapsize){
                    int left = index * 2 + 1;
                    while(left < heapsize){
            //            largest就是记录我左右孩子中较大的数的位置
            //            这句话的意思就是只有你左右孩子都在，并且不越界，并且右孩子的值比左孩子大，才会作为largest的取到的坐标值出现，否则的话就是左孩子
                        int largest = left + 1 < heapsize && arr[left + 1] > arr[left] ? left + 1:left;
            //            左右两个孩子之间的最大值和我之间哪个值大，哪个坐标就作为largest的值出现
                        largest = arr[index] > arr[largest] ? index : largest;
            //            当值还是我最大，那么什么都不变
                        if(largest == index){
                            break;
                        }
            //           我的值小，交换我和较大孩子的值
                        swap(arr , index ,largest);
            //            将我的坐标和较大孩子的坐标交换，然后继续判断我要不要继续往下沉
                        index = largest;
                        left = index * 2 + 1;
                    }
                }
                /*建立大根堆，大值往上跑*/
                public static void heapInsert(int[] arr, int index){
            //        即使当index = 0的时候， -1/2也等于0
                    while(arr[index] > arr[( index - 1 ) / 2]){
                        swap(arr, index, ( index - 1 ) / 2);
                        index = (index - 1) / 2;
                    }
                }
                public static void swap(int[] arr, int i,int j){
                    int temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                }
                public static void main(String[] args){
                    int[] arr = {1, 2, 4, 6, 3, 5, 8};
                    heapsort(arr);
                    System.out.println(Arrays.toString(arr));
                }
            }

    ```
