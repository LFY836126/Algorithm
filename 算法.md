## 题库
1. 剑指offer题库：`https://www.acwing.com/problem/search/2/?csrfmiddlewaretoken=Lfru0f60yxMyo7cb5M0yhKIVmdNnVgliSa5L8c7rB5MeFmDNt3QVwQ149XZ8p7E3&search_content=%E5%89%91%E6%8C%87offer`
2. 剑指offer题解：`https://blog.csdn.net/FlushHip/column/info/19892`
3. 剑指offer视频：`https://www.bilibili.com/video/av39556817`

## 时间复杂度
```
    认识时间复杂度
        常数时间的操作：一个操作如果和数据量没有关系，每次都是固定时间内完成的操作，叫做常数操作。

    时间复杂度为一个算法流程中，常数操作数量的指标。常用O（读作big O）来表示。具体来说，在常数操作数量的表达式中，只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分，如果记为f(N)，那么时间复杂度为O(f(N))。

    评价一个算法流程的好坏，先看时间复杂度的指标，然后再分析不同数据样本下的实际运行时间，也就是常数项时间。
```
例1： 一个简单的理解时间复杂度的例子：一个有序数组A，另一个无序数组B，请打印B中的所有不在A中的数，A数组长度为N，B数组长度为M。
```
    算法流程1：对于数组B中的每一个数，都在A中通过遍历的方式找一下；
    算法流程2：对于数组B中的每一个数，都在A中通过二分的方式找一下；
    算法流程3：先把数组B排序，然后用类似外排的方式打印所有在A中出现的数；
    三个流程，三种时间复杂度的表达... 如何分析好坏？
```

## 对数器
1. 对数器的概念和使用
    ```
    0，有一个你想要测的方法a，
    1，实现一个绝对正确但是复杂度不好的方法b，
    2，实现一个随机样本产生器
    3，实现比对的方法
    4，把方法a和方法b比对很多次来验证方法a是否正确。
    5，如果有一个样本使得比对出错，打印样本分析是哪个方法出错
    6，当样本数量很多时比对测试依然正确，可以确定方法a已经正确。
    ```
2. 代码实现
    ```
    //  生出长度随机的数组
        // for test
        public static int[] generateRandomArray(int maxSize, int maxValue) {
            int[] arr = new int[(int) ((maxSize + 1) * Math.random())];
            for (int i = 0; i < arr.length; i++) {
                arr[i] = (int) ((maxValue + 1) * Math.random()) - (int) (maxValue * Math.random());
            }
            return arr;
        }
    //  比较两个数组
        public static boolean isEqual(int[] arr1, int[] arr2) {
            if ((arr1 == null && arr2 != null) || (arr1 != null && arr2 == null)) {
                return false;
            }
            if (arr1 == null && arr2 == null) {
                return true;
            }
            if (arr1.length != arr2.length) {
                return false;
            }
            for (int i = 0; i < arr1.length; i++) {
                if (arr1[i] != arr2[i]) {
                    return false;
                }
            }
            return true;
        }
    //一个绝对正确的方法
        public static void comparator(int[] arr) {
            Arrays.sort(arr);
        }

    //拷贝数组
        public static int[] copyArray(int[] arr) {
            if (arr == null) {
                return null;
            }
            int[] res = new int[arr.length];
            for (int i = 0; i < arr.length; i++) {
                res[i] = arr[i];
            }
            return res;
        }

    //  对数器
    public static void main(String[] args) {
            int testTime = 500000;
                //数组长度
            int maxSize = 100;
                //数在0-100之间
            int maxValue = 100;
            boolean succeed = true;
            for (int i = 0; i < testTime; i++) {
                int[] arr1 = generateRandomArray(maxSize, maxValue);
                int[] arr2 = copyArray(arr1);
                bubbleSort(arr1);
                comparator(arr2);
                if (!isEqual(arr1, arr2)) {
                    succeed = false;
                    break;
                }
            }
            System.out.println(succeed ? "Nice!" : "Fucking fucked!");

            int[] arr = generateRandomArray(maxSize, maxValue);
            printArray(arr);
            bubbleSort(arr);
            printArray(arr);
        }
    ```

## 排序
### 冒泡排序
```
    冒泡排序细节的讲解与复杂度分析
    时间复杂度O(N^2)，额外空间复杂度O(1)

    思路：每次找最大的数放在后面，范围不断缩小

    代码：
            // 时间复杂度O(N^2)，额外空间复杂度O(1)
            public class BubbleSort {
                public static void bubblesort(int [] arr){
                    for(int i = arr.length - 1;i > 0 ;i --){
                        for(int j = 0; j < i;j++){
                            if(arr[j] > arr[j+1]){
                                swap(arr, j, j+1);
                            }
                        }
                    }
                }
                public static void swap(int[] arr, int i, int j){
                    int temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                }
                public static void main(String [] args){
                    int[] arr = {4 , 2 , 3 , 1};
                    bubblesort(arr);
                    System.out.println(Arrays.toString(arr));
                }
            }
```
### 选择排序
```
    选择排序的细节讲解与复杂度分析
    时间复杂度O(N^2)，额外空间复杂度O(1)

    思路：0到n-1上最小的数和0位置上交换，1到n-1上最小的数和1位置上交换，以此类推

    代码：
            // 时间复杂度O(N^2)额外空间复杂度O(1)
            public class SelectionSort {
                public static void selectsort(int[] arr){
                    for(int i = 0; i < arr.length; i++){
                        int minIndex = i;
                        for(int j = i + 1; j <arr.length; j ++ ){
                            minIndex = arr[j] < arr[minIndex] ? j : minIndex;
                        }
                        swap(arr, i, minIndex);
                    }
                }
                public static void swap(int[] arr, int i, int j){
                    int temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                }
                public static void main(String [] args){
                    int[] arr = {3, 5, 2, 4, 1};
                    selectsort(arr);
                    System.out.println(Arrays.toString(arr));
                }

            }
```
### 插入排序
```
    插入排序的细节讲解与复杂度分析
    时间复杂度O(N^2)，额外空间复杂度O(1)

    思路：就像自己手里攥了好多牌，攥的牌是已经排好的，但是新抓了一张牌，这张牌就看能滑到哪个位置上插进去

    代码：
            //    时间复杂度O(N^2)，额外空间复杂度O(1)
            public class InsertSort {
                public static void insertsort(int[] arr){
                    for(int i = 1; i < arr.length; i++){
                        for(int j = i - 1;j >= 0 && arr[j+1] < arr[j]; j--){
                            swap(arr, j, j+1);
                        }
                    }
                }
                public static void swap(int[] arr, int i, int j){
                    int temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                }
                public static void main(String [] args){
                    int[] arr = {5, 3, 2, 4, 1};
                    insertsort(arr);
                    System.out.println(Arrays.toString(arr));
                }
            }
```
### 归并排序
#### master公式
```
    剖析递归行为和递归行为时间复杂度的估算
    一个递归行为的例子
    master公式的使用
    T(N) = a*T(N/b) + O(N^d)
    1) log(b,a) > d -> 复杂度为O(N^log(b,a))
    2) log(b,a) = d -> 复杂度为O(N^d * logN)
    3) log(b,a) < d -> 复杂度为O(N^d)
    补充阅读：www.gocalf.com/blog/algorithm-complexity-and-mastertheorem.html

    master适用范围：所有子过程规模必须一样
```
#### 归并排序
```
    归并排序的细节讲解与复杂度分析
    时间复杂度O(N*logN)，额外空间复杂度O(N)

    归并排序快的实质：没有浪费比较，充分利用了每次比较，因为冒泡排序等排序方法，每次比较只搞定了一个数，浪费了很多比较

    代码：
        public class Merge {
            public static void mergesort(int[] arr){
                if(arr == null || arr.length < 2){
                    return;
                }
                mergesort(arr, 0, arr.length-1);
            }
            public static void mergesort(int[] arr, int l, int r){
                    //递归函数出口
                if(l == r){
                    return;
                }
                int mid = l + ((r - l) >> 1);
                    //左边排好序，右边排好序
                mergesort(arr, l, mid);
                mergesort(arr, mid + 1, r);
                    //利用外排将左右排好序的数组放在一个新的数组中，然后拷贝给原数组
                merge(arr, l, r, mid);
            }
            public static void merge(int arr[], int l, int r, int m){
                int i = 0;
                int p1 = l;
                int p2 = m+1;
                    //生成辅助数组
                int[] help = new int[r - l + 1];
                while(p1 <= m && p2 <= r){
                    help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
                }
                while(p1 <= m){
                    help[i++] = arr[p1++];
                }
                while(p2 <= r){
                    help[i++] = arr[p2++];
                }
                for(int j= 0; j < help.length; j ++){
                    arr[l + j] = help[j];
                }
            }
            public static void swap(int[] arr, int i, int j){
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
            public static void main(String [] args){
                int[] arr = {4 , 2 , 1, 3};
                mergesort(arr);
                System.out.println(Arrays.toString(arr));
            }
        }
```
#### 小和问题和逆序对问题
1. 小和问题：在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。
    ```
    例子：
            [1,3,4,2,5]
            1左边比1小的数，没有；
            3左边比3小的数，1；
            4左边比4小的数，1、3；
            2左边比2小的数，1；
            5左边比5小的数，1、3、4、2；
        所以小和为1+1+3+1+1+3+4+2=16

    思路：
        我在每次merge过程中，先将产生的小和存起来，然后将当前部分进行排序，再后续炸出小和
        先边排序边求左部分小和，然后边排序边求右部分小和，然后整体边排序边求小和
        排序和求小和过程：谁小谁后移动，若是左部分小，res += (右面当前位置往后元素的个数) * 左部分当前位的值，若是右半部分小，不产生小和，不做计算，指针后移

    代码：
        public class SmallSum {
            public static void mergesort(int[] arr){
                if (arr == null|| arr.length < 2) {
                    return;
                }
                System.out.println(mergesort(arr, 0, arr.length - 1));
            }
            public static int mergesort(int[] arr, int l, int r){
                if(l == r){
                    return 0;
                }
                /*不使用(l + r)/2，而是使用l + ((r - l)>>1)，可以防止溢出，而且位运算比算术运算快很多
                注意右移必须加括号，要不会报错
                */
                int mid = l + ((r - l)>>1);
                return mergesort(arr, l, mid) + mergesort(arr, mid + 1, r) + merge(arr, l, mid, r);
            }
            public static int merge(int[] arr, int l, int m, int r){
                int p1 = l;
                int p2 = m + 1;
                int res = 0;
                int i= 0;
                /*这里的长度也要根据传进来的数判断，不能生成随便长度的数组*/
                int[] help = new int[r - l + 1];
                while(p1 <= m && p2 <= r){
                res += arr[p2] > arr[p1] ? arr[p1] * ( r - p2 + 1 ) : 0;
                help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
                }
                while(p1<=m){
                    help[i++] = arr[p1++];
                }
                while(p2 <= r){
                    help[i++] = arr[p2++];
                }
                /*这里注意是help.length和arr[l+j]，不能写j，万一参数是2或者3什么的，这里的差别就很明显了，因为每次传进来的参数不一样，长度就有可能不一样，*/
                for(int j =0;j < help.length;j++){
                    arr[l+j] = help[j];
                }
                return res;
            }
            public static void main(String [] args){
                int[] arr = {2, 3, 1, 4};
                mergesort(arr);
            }
        }

    ```
2. 逆序对问题
    ```
        在一个数组中，左边的数如果比右边的数大，则折两个数构成一个逆序对，请打印所有逆序对。
    ```

### 快排
1. 
    + 例题1
        ```
        给定一个数组arr，和一个数num，请把小于等于num的数放在数
        组的左边，大于num的数放在数组的右边。

        要求额外空间复杂度O(1)，时间复杂度O(N)

        ```
    + 例题2:（荷兰国旗问题）
        ```
        问题：给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边。

        要求：额外空间复杂度O(1)，时间复杂度O(N)

        思路：
            三个变量
            less: 存储小于区域的最后一个位置
            more：存储大于区域的第一个位置
            cur：当前位置
            当 当前位置的数小于num，那么就将cur指向的数和小于区域下一个位置交换，然后less ++(小于区域扩大一个位置)， cur++(指针向后移动一位)
            当 当前位置的数等于num，什么都不做，cur++(cur向后移动一位)，继续判断，
            当 当前位置的数大于num，将cur指向的数和大于区域的前一个位置交换，然后more --，然后cur不变，继续判断我换过来的这个数，大于小于还是等于num

        代码： 
            public class NetherlandsFlag {
                public static void partition(int[] arr, int num ,int L, int R){
                    int less = L -1;
                    int more = R + 1;
                    int cur = L;
                    while(cur < more){
                        if(arr[cur] < num){
                            swap(arr, cur++, ++less);
                        }
                        else if(arr[cur] > num){
                            swap(arr, cur, --more);
                        }
                        else{
                            cur ++;
                        }
                    }
                }
                public static void swap(int[] arr, int i,int j){
                    int temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                }
                public static void main(String [] args){
                    int num = 5;
                    int[] arr = {10, 9, 8, 5, 7, 6, 5, 4, 3, 2, 1};
                    partition(arr, num, 0, 10);
                    System.out.println(Arrays.toString(arr));
                }
            }

        ```
2. 经典快排
    + 思路：就是在荷兰国旗的问题上，将大于区域最后一个数(num)一开始就不让它参与遍历，最后再让它归位
        ```
            将最后一个位置的数作为num，我每次都将小于等于num的放在左边，大于num的数放在右面，
            我将最后一位的数也就是等于num的数放在more中，
            最后，将最后一位上的数和more交换，
            因为more位置上的数一定是大于num中最靠左位置的，然后我将more和最后一位上的数，也就是等于num的数进行交换
            此时就完成了所有的数小于靠左，大于靠右，等于靠中间
        ```
    + 代码：见随机快排
    + 存在的问题：总拿最后一个数去划分是和我的数据状况有关系的，
        - 比如：[1,2,3,4,5,6],每次我都拿最后一个数去划分，每次也就只能搞定一个数，所以，时间复杂度就是O(N^2)，
        - 又比如我每次都正正好好打在中间，那么我的时间复杂度利用master公式得到就是O(N*logN)
3. 随机快排
    ```
    随机快速排序的细节和复杂度分析可以用荷兰国旗问题来改进快速排序时间复杂度O(N*logN)，额外空间复杂度O(logN)

    解释额外空间复杂度：使用额外空间这个事是一个概率，如果每次都打到中间，那么额外空间复杂度就是O(logN)，但是数据状况是不确定的，所以长期期望是O(logN)

    思路：     
        每次随机选择一个数，把它和最后一个位置上的数进行交换，然后拿这个随机的数做这样的划分
    注意：工程上快排是非递归版本的

    代码：
        public class QuickSort {
            public static void quicksort(int[] arr){
                if(arr == null || arr.length < 2){
                    return ;
                }
                quicksort(arr, 0, arr.length-1);
            }
            public static void quicksort(int[] arr, int l, int r){
                if(l < r){
                    int[] p = partition(arr, l, r);
                    quicksort(arr, l, p[0] - 1);
                    quicksort(arr, p[1] + 1, r);
                }
            }
            public static int[] partition(int[] arr, int l, int r){
                swap(arr , (int)(Math.random() * (r - l + 1)) + l, r);
                int less = l - 1;
                int more = r;
                int cur = l;
                while(cur < more){
                    if(arr[cur] < arr[r]){
                        swap(arr , ++less, cur++);
                    }
                    else if(arr[cur] > arr[r]){
                        swap(arr , --more, cur);
                    }
                    else{
                        cur ++;
                    }
                }
                swap(arr, r, more);
                return new int[]{ less + 1, more};
            }
            public static void swap(int[] arr, int i, int j){
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
            public static void main(String[] args){
                int[] arr = {3, 6, 2, 5, 4, 3, 2};
                quicksort(arr);
                System.out.println(Arrays.toString(arr));
            }
        }

    ```
4. 补充：有些算法我想绕开它本身的数据状况怎么办
    + 我用随机这个东西打乱你的数据状况
    + 哈希函数打乱

### 堆排

#### 基础概念
1. 二叉树两个概念
    + 完全二叉树
    + 满二叉树
2. 堆的概念(堆就是完全二叉树)
    + 大根堆：在完全二叉树中任何一个子树的最大值就是这个子树的头部
        - 时间复杂度为log1 + log2 +  ..... + log(N-1) = O(N),因为，每一个结点调整建立大根堆的过程，就是此时形成完全二叉树的高度，完全二叉树的高度就是logN
    + 小根堆：在完全二叉树中任何一个子树的最小值就是这个子树的头部
3. 数组对应脑海中的逻辑上的完全二叉树
    ```
    i   
        左孩子： 2 * i + 1
        右孩子： 2 * i + 2
        父节点： (i - 1) / 2
    ```
4. 
    + heapInsert(建立大根堆)，当新添值后，不断往上走的过程
    + heapify，当我某个值变小了，我要经历往下调整,小值往下扎，也是建立大根堆的过程
5. 例题1：我有几个机制，就是每次都向外吐一个数，要求，当我在求出任意时刻的中位数
    ```
    思路：我建立两个堆，一个大根堆，一个小根堆，每当新吐出来一个数的时候，我就将当前数和大
        根堆的堆顶比较，如果当前数小于等于大根堆堆顶，我才进去大根堆，
        然后当大根堆和小根堆中数的个数差值大于1的话
        (因为我要保证两个堆数量都趋近于n/2)，我将数量多的那个堆的堆顶弹到另
        个堆中，重新形成大根堆或者小根堆，
        这样就保证了，较小的n/2在大根堆中，较大的n/2在小根堆中
        这样就可以随时拿到中位数
    利用堆的好处：每次我调整大根堆或者小根堆的代价只是O(logN)的，很低的复杂度

    ```

#### 堆排
1. 思路:
一个数组让它整体都形成一个大根堆，然后把最后一个位置和堆顶位置做交换，就相当于我形成一个大根堆，我每次都把这个大根堆的最后一个位置和头部交换，头部换回来之后，就把它从堆上减掉，然后我再调整缩小范围的这个堆，重新调整成一个大根堆，直到我堆的大小剪完，所有的最大值依次被填在了倒数第一，倒数第二......最后填到0位置，整个数组排完序
2. 特点：这个结构已经形成了大小为n，进来一个数是代价O(logN)能够搞定的
3. 代码：
    ```
            package myP;
            import java.util.Arrays;

            public class HeapSort {
                public static void heapsort(int[] arr){
                    if(arr == null || arr.length < 2){
                        return ;
                    }
                    /*建立大根堆的过程·*/
                    for(int i = 0; i < arr.length; i++){
                        heapInsert(arr , i);
                    }
                    int heapsize = arr.length;
                    /*将大根堆的头部与末尾的数进行交换，然后将换来的数一点一点往下沉，找到合适的位置，重新建立大根堆heapify*/
                    swap(arr, 0, --heapsize);
                    while(heapsize > 0){
                        heapify(arr, 0, heapsize);
                        swap(arr, 0, --heapsize);
                    }
                }
                /*小值往下扎*/
                public static void heapify(int[] arr, int index, int heapsize){
                    int left = index * 2 + 1;
                    while(left < heapsize){
            //            largest就是记录我左右孩子中较大的数的位置
            //            这句话的意思就是只有你左右孩子都在，并且不越界，并且右孩子的值比左孩子大，才会作为largest的取到的坐标值出现，否则的话就是左孩子
                        int largest = left + 1 < heapsize && arr[left + 1] > arr[left] ? left + 1:left;
            //            左右两个孩子之间的最大值和我之间哪个值大，哪个坐标就作为largest的值出现
                        largest = arr[index] > arr[largest] ? index : largest;
            //            当值还是我最大，那么什么都不变
                        if(largest == index){
                            break;
                        }
            //           我的值小，交换我和较大孩子的值
                        swap(arr , index ,largest);
            //            将我的坐标和较大孩子的坐标交换，然后继续判断我要不要继续往下沉
                        index = largest;
                        left = index * 2 + 1;
                    }
                }
                /*建立大根堆，大值往上跑*/
                public static void heapInsert(int[] arr, int index){
            //        即使当index = 0的时候， -1/2也等于0
                    while(arr[index] > arr[( index - 1 ) / 2]){
                        swap(arr, index, ( index - 1 ) / 2);
                        index = (index - 1) / 2;
                    }
                }
                public static void swap(int[] arr, int i,int j){
                    int temp = arr[i];
                    arr[i] = arr[j];
                    arr[j] = temp;
                }
                public static void main(String[] args){
                    int[] arr = {1, 2, 4, 6, 3, 5, 8};
                    heapsort(arr);
                    System.out.println(Arrays.toString(arr));
                }
            }

    ```

### 排序的稳定性
1. 概念：将数组排序之后，我能否保证原始的相对次序不变
2. 所有排序的稳定性
    ```
    冒泡排序： 可以实现成稳定的，当碰到相等的情况，我不换，继续往下走，就可以实现稳定的
    插入排序： 可以实现成稳定的，当碰到相等的情况，我不换，继续往前走，就可以实现稳定的
    选择排序： 无论怎样都做不到稳定性

    归并排序： 可以实现成稳定的，遇到相等的先拷贝左边的
    快排   ：  做不到稳定性，因为partition做不到稳定性
    堆排序 ：  做不到稳定性，因为建立大根堆的过程就做不到稳定性
    ```

### 介绍一下工程中的综合排序算法
1. 插排的优势，当整个数组长度小于60的情况下，直接用插排，因为样本量小的时候，插排的劣势显示不出来，反而插排的常数项很低，所以用插排
2. 综合排序：综合排序过程中，里面如果放置的是基础类型就用快排(不用考虑稳定性)，如果放置的是你自己定义的类型(就像学生的分数，年纪等，需要保证稳定性)，就用归并排，当R - L < 60的时候就用插排

### 有关排序问题的补充
1. 归并排序的额外空间复杂度可以变成O(1)，但是非常难，不需要掌握，可以搜“归并排序 内部缓存法”
2. 快速排序可以做到稳定性问题，但是非常难，不需要掌握，可以搜“01 stable sort”
3. 有一道题目，是奇数放在数组左边，偶数放在数组右边，还要求原始的相对次序不变，碰到这个问题，可以怼面试官。面试官非良人。
    + 奇和偶叫0-1标准，快排中按照值来划分，<=放左边，>放右边，也是0-1标准，因为快排很难做到稳定性，所以奇偶也很难做到
4. partition在额外空间复杂度为O(1),时间复杂度为O(N)的情况下做不到稳定性，所以，快排和荷兰国旗问题在这样的情况下都做不到稳定性，因为都有partition

### 简略
1. Code_09_Comparator
2. 系统给你提供的一个有序的结构，你方便使用的时候，都会伴随着一个比较器的构造，比较器就是你在一个有序的结构中，你要怎么组织这个结构的，既可以做排序也可以做优先级队列，可以做TreeMap,重点就是：定义两个东西怎么比较大小

### 桶排序、计数排序、基数排序的介绍
1. 非基于比较的排序，与被排序的样本的实际数据状况很有关系，所以实际中并不经常使用
2. 时间复杂度O(N)，额外空间复杂度O(N)
3. 稳定的排序

#### 补充例题
1. 给定一个数组，求如果排序之后，相邻两数的最大差值，要求时间复杂度O(N)，且要求不能用非基于比较的排序。
    + 思路:
        n个数准备n + 1个空桶，划分为n + 1 个空间，然后将数组中的数，符合哪个范围就放入哪个桶中，所以一定会产生一个空桶
        而且我每次放一个数，桶只计算三个值，最小值，最大值，，记录是否为空桶
        那么我们这里就杀死了一个可能性，就是我们这里求的最大差值一定不是来自于一个桶内部的数
        因为一个桶中数最大的差值一定小于等于划分范围，然而空桶左侧非空桶的最大值，和空桶右侧非空桶的最小值差值就已经超过了这个划分范围，
    + 代码：
        ```
        public class MaxGap {
            public static int maxgap(int[] arr){
                if(arr == null || arr.length < 2){
                    return 0;
                }
                int len = arr.length;
                int max = Integer.MIN_VALUE;
                int min = Integer.MAX_VALUE;
                //找到数组中的最小值和最大值
                for(int i = 0; i < len; i++){
                    max = Math.max(arr[i], max);
                    min = Math.min(arr[i], min);
                }
                //如果最小值等于了最大值,那么说明数组中就一种数，都相等，最大差值就为0
                if(max == min){
                    return 0;
                }
                //0号桶到n号桶的三个信息，用数组表示
                boolean[] hasNum = new boolean[len + 1];
                int[] mins = new int[len + 1];
                int[] maxs = new int[len + 1];
                int bid = 0;
                for(int i = 0; i < len; i ++){
                    //判断我这个数应该去几号桶
                    bid = bucket(arr[i] , len, min, max);
                    //将这个桶的三个信息进行更新
                    mins[bid] = hasNum[bid] ? Math.min(mins[bid], arr[i]): arr[i];
                    maxs[i] = hasNum[bid] ? Math.max(maxs[bid], arr[i]): arr[i];
                    hasNum[bid] = true;
                }
                int res = 0;
                int lastIndex = maxs[0];
                //找到每个非空桶和离它最近的左边非空桶，用当前的最小减去前一个的最大
                for(int i = 1; i < len; i ++){
                    if(hasNum[i]){
                        res = Math.max(mins[i] - lastIndex, res);
                        lastIndex = maxs[i];
                    }
                }
                return res;
            }
            public static int bucket(long num, long len, long min, long max) {
                return (int) ((num - min) * len / (max - min));
            }
            public static void main(String[] args){
                int[] arr = {1, 1, 7, 6, 5, 3};
                System.out.println(maxgap(arr));
            }

        }

        ```
2. 用数组结构实现大小固定的队列和栈
    + 思路：
        ```
        假定数组大小为3
        (1)实现栈
            index代表如果用户想让我新加一个数，我应该把它放在什么位置
            index如果在0位置，用户想让我给它弹出一个数，或者如果index在3的位置上用户还想再加一个数，那么我就提示报错
        (2)实现队列
            start变量：如果我要拿去一个数，我要把哪个位置上的数拿过来，并且只要start到底了，我就回到开头，否则就向下走一个
            end变量：如果新加一个数，我应该把它填到哪个位置上，并且只要end到底了，我就回到开头，否则就向下走一个
            size变量：约束start和end变量的行为，如果size没有到3，那么我就把用户新给我的那个数放在end的位置上去，如果size不等于0，我总把start指向位置的数给用户，end和start是独立的，解耦的
        ```
    + 代码
        ```
        public class Array_To_Stack_Queue {
            public static class ArrayStack{
                private Integer [] arr;
                private Integer size;

                /*判断数组长度是否正确*/
                public ArrayStack(int initsize){
                    if(initsize < 0){
                        throw new IllegalArgumentException("The init size is less than 0");
                    }
                    /*初始化数组*/
                    arr = new Integer[initsize];
                    /*size是当前可以放东西的位置，可以看作是空的*/
                    size = 0;
                }
                /*返回栈顶存的东西*/
                public Integer peek(){
                    if(size == 0){
                        return null;
                    }
                    return arr[size - 1];
                }
                /*向当前位添加*/
                public void push(int obj){
                    if(size == arr.length ){
                        throw new ArrayIndexOutOfBoundsException("This queue is full");
                    }
                    arr[size++] = obj;
                }
                /*弹出栈顶位置的元素*/
                public Integer pop(){
                    if(size == 0){
                        throw new ArrayIndexOutOfBoundsException("The queue is empty");
                    }
                    return arr[--size];
                }
            }
            public static class ArrayQueue{
                private Integer [] arr;
                private Integer size;
                private Integer last;
                private Integer start;
                public ArrayQueue(int initsize){
                    if(initsize < 0){
                        throw new IllegalArgumentException("The init size is less than 0");
                    }
                    arr = new Integer[initsize];
                    /*size表示我还没有没有空间放东西，就是数组满没满*/
                    size = 0;
                    /*last表示我当前位置可以放东西。可以当作原本是空的*/
                    last = 0;
                    /*指向当前栈顶元素*/
                    start = 0;
                }
                public void push(int obj){
                    if(size == arr.length){
                        throw new ArrayIndexOutOfBoundsException("This queue is full");
                    }
                    size ++;
                    arr[last] =obj;
                    last = last == arr.length -1 ? 0: last + 1;
                }
                public Integer poll(){
                    if(size == 0){
                        throw new ArrayIndexOutOfBoundsException("The queue is empty");
                    }
                    size --;
                    int tmp = start;
                    start = start == arr.length ? 0 : start + 1;
                    return arr[tmp];
                }
            }
            public static void main(String[] args) {

            }
        }

        ```
3. 实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。
    + 要求
        - pop、push、getMin操作的时间复杂度都是O(1)。
        - 设计的栈类型可以使用现成的栈结构。  
    + 思路：
        ```
        (1)第一种方法
            准备两个栈，第一个栈就是Data栈，第二个就是min栈
            我在压数的过程中，min栈随着Data一起增长，每当我压入一个数，我就让当前数和min栈的栈顶进行比较，如果当前数更小，min栈就压当前数，否则就重复压入一个min栈的栈顶，min栈的栈顶就是所有数中最小的那个数，弹出的过程中，同步弹出就可以了，Data弹一个，min也弹一个
        (2)第二种方法
            在第一种的基础上，min栈压入条件改变，当前数和min栈的栈顶进行比较，如果当前数小于等于栈顶的数，min栈就压当前数，否则不变，min栈的栈顶就是所有数中最小的那个数，弹出的过程中，当前的数如果和栈顶的数相等，那就两个都弹出，否则只弹出Data栈中的内容，min栈不变
        ```
    + 代码：
        ```
        public class GetMinStack {
            public static class MyStack{
                /*两个栈，一个是数据栈，一个是存放最小值的那个栈（栈顶位置的数一定是最小的）*/
                private Stack<Integer>stackData;
                private Stack<Integer>stackMin;
                public MyStack(){
                    this.stackData = new Stack<Integer>();
                    this.stackMin = new Stack<Integer>();
                }
                /*将新进来的数与stackMin的栈顶进行比较，要是小于或者等于，那在stackMin中也push newNum*/
                public void push(int newNum){
                 if(this.stackMin.isEmpty()) {
                     this.stackMin.push(newNum);
                 }else if(newNum <= this.getMin()){
                     this.stackMin.push(newNum);
                 }
                 /*不管如何，最终的stackData中肯定是要push新的数的*/
                 this.stackData.push(newNum);
                }
                /*弹出数，要是弹出的数等于stackMin中栈顶的数，那就一起都带走，就是两个都弹出*/
                public int pop(){
                    if(this.stackData.isEmpty()){
                        throw new RuntimeException("Your stack is empty.");
                    }
                    int value = this.stackData.pop();
                    if(value == this.getMin()){
                        this.stackMin.pop();
                    }
                    return value;
                }
                /*得到stackMin这个栈 栈顶的位置*/
                public int getMin(){
                    if(this.stackMin.isEmpty()){
                        throw new RuntimeException("Your stack is empty.");
                    }
        //            只得到数值，不弹出
                    return this.stackMin.peek();
                }
            }
            public static void main(String [] args){
                MyStack stack = new MyStack();
                stack.push(3);
                stack.push(4);
                stack.push(1);
                System.out.println(stack.getMin());
                stack.pop();
                System.out.println(stack.getMin());
                stack.pop();
                System.out.println(stack.getMin());
            }
        }

        ```
4. 如何仅用队列结构实现栈结构？(先进后出)，如何仅用栈结构实现队列结构？(先进先出)
    + 思路：
        - 队列->栈
            准备两个队列，一组数据进入队列(头进尾出)，比如为[5, 4, 3, 2, 1], 5是头，1是尾，然后我要弹出一个数，也就是5，那么我将前面的数入另一个队列，最后一个别入，给用户返回了
        - 栈->队列
            push：用户给我的数永远进push栈
            pop： 用户想让我给它一个数，永远从pop栈中拿
            比如一组数1,2,3,4,5入栈push ->5, 4, 3, 2, 1,如果用户让我给他一个数，我先将数导入另一个栈pop中，变为->1, 2, 3, 4, 5，我从pop栈中给他拿
            倒的过程两个注意点：
            1.pop中得为空，不为空直接返回，倒不了
            2.push得一次性倒完，什么时候倒完什么时候才停止，
    + 代码：
        ```
        import java.util.LinkedList;
        import java.util.Queue;
        import java.util.Stack;

        public class StackAndQueueConvert {
            /*用两个队列来实现栈结构
            栈：push和pop
            队列：push和poll
            */
            public static class TwoQueuesStack{
                private Queue<Integer>queue;
                private Queue<Integer>help;
                public TwoQueuesStack() {
                    queue = new LinkedList<Integer>();
                    help = new LinkedList<Integer>();
                }
                public void push(int pushInt){
                    queue.add(pushInt);
                }
                public int pop(){
                    if(queue.isEmpty()){
                        throw new RuntimeException("Stack is empty!");
                    }
                    /*只要是不剩最后一个，我就一直把queue中的内容倒到help中*/
                    while(queue.size() > 1){
                        help.add(queue.poll());
                    }
                    /*我得先在这里存一下最后的结果，以便最后返回，不能直接返回，要不然就没法执行交换的操作了*/
                    int res = queue.poll();
                    /*交换，help变为queue，queue变为空的help队列,改变两个引用*/
                    swap();
                    return res;
                }
                public void swap(){
                    Queue<Integer>tmp = queue;
                    queue = help;
                    help = tmp;
                }
            }
            public static class TwoStacksQueue{
                //用两个栈来实现队列结构
                private Stack<Integer> stackPush;
                private Stack<Integer> stackPop;
                public TwoStacksQueue(){
                    stackPush = new Stack<Integer>();
                    stackPop = new Stack<Integer>();
                }
                public void  push(int pushInt){
                    stackPush.push(pushInt);
                    /*dao();随时随地都可以发生倒数据行为，只要满足了那两个条件*/
                }
                public int poll(){
                    if(stackPop.isEmpty()&&stackPush.isEmpty()){
                        throw new RuntimeException("Queue is empty!");
                    }
                    dao();
                    return stackPop.pop();
                }
                public void dao(){
                    /*倒的过程两个注意点：
                    1.pop中得为空，不为空直接返回，倒不了
                    2.push得一次性倒完，什么时候倒完什么时候停止，
                    只要满足这两个条件什么时候都能发生倒数据行为，随时都可以！
                    */
                    if(!stackPop.isEmpty()){
                        return;
                    }
                    while(!stackPush.isEmpty()){
                        stackPop.push(stackPush.pop());
                    }
                }
            }
        }
        ```
5. 猫狗队列 
    + 题目：
        ```
        宠物、狗和猫的类如下：
        public class Pet { 
            private String type;
            public Pet(String type) { 
                this.type = type; 
            }
            public String getPetType() { 
                return this.type; 
            }
        }
        public class Dog extends Pet { public Dog() { super("dog"); } }
        public class Cat extends Pet { public Cat() { super("cat"); } }
        实现一种狗猫队列的结构，
        ```
    + 要求如下： 
        ```
        用户可以调用add方法将cat类或dog类的实例放入队列中； 
        用户可以调用pollAll方法，将队列中所有的实例按照进队列的先后顺序依次弹出； 
        用户可以调用pollDog方法，将队列中dog类的实例按照进队列的先后顺序依次弹出； 
        用户可以调用pollCat方法，将队列中cat类的实例按照进队列的先后顺序依次弹出； 
        用户可以调用isEmpty方法，检查队列中是否还有dog或cat的实例； 
        用户可以调用isDogEmpty方法，检查队列中是否有dog类的实例； 
        用户可以调用isCatEmpty方法，检查队列中是否有cat类的实例。
        ```
    + 思路：
        ```
        我准备两个队列，一个狗队列，一个猫队列
        然后准备一个count，就是时间戳的意思
        ```
    + 代码：
        ```
        Code_04_DogCatQueue
        ```
6. 转圈打印矩阵
    + 题目：给定一个整型矩阵matrix，请按照转圈的方式打印它。例如： 
        ```
            1  2  3  4 
            5  6  7  8 
            9  10 11 12 
            13 14 15 16 
        ```
        打印结果为：1，2，3，4，8，12，16，15，14，13，9，5，6，7，11， 10
    + 要求：额外空间复杂度为O(1)。
    + 思路：
        ```
        确定左上角和右下角，然后通过下标变化，顺时针打印出一圈，然后将左上角，右下角的坐标都往里圈移一个，接着顺时针打印里圈，知道左上角的行或者列大于右下角的行或者列，停止
        ```
    + 代码：
        ```
        public class PrintMatrixSpiralOrder {
            public static void spiralOrderPrint(int[][] matrix){
                /*用两个点，四个坐标来打印第一圈矩形，再把两个点的坐标往里推一个，转圈打印里面一层的矩形，以此类推*/
                int tR = 0;//上x
                int tC = 0;//上y
                int dR = matrix.length - 1;//下x
                int dC = matrix[0].length - 1;//下y
                while (tR <= dR && tC <= dC) {
                    printEdge(matrix , tR++, tC++, dR--, dC--);
                }
            }
            public static void printEdge(int[][] matrix, int tR, int tC, int dR, int dC){
                if(tC == dC){
                    for(int i = 0;i <= dR - tR; i ++ ){
                        System.out.print(matrix[tR+i][tC] + " ");
                    }
                }else if(tR == dR){
                    for(int i = 0;i <= dC - tC; i ++ ){
                        System.out.print(matrix[tR][tC+i] + " ");
                    }
                }else{
                    int curR = tR;
                    int curC = tC;
                    while(curC != dC){
                        System.out.print(matrix[tR][curC ++] + " ");
                    }
                    while(curR != dR){
                        System.out.print(matrix[curR ++][dC]+ " ");
                    }
                    while(curC != tC){
                        System.out.print(matrix[dR][curC --]+ " ");
                    }
                    while(curR != tR){
                        System.out.print(matrix[curR --][tC]+ " ");
                    }
                }
            }
            public static void main(String[] args){
                int[][] Matrix = {
                        {1, 2, 3, 4},
                        {5, 6, 7, 8},
                        {9, 10, 11, 12},
                        {13, 14, 15, 16}
                };
                spiralOrderPrint(Matrix);
            }
        }

        ```
7. 旋转正方形矩阵
    + 题目：定一个整型正方形矩阵matrix，请把该矩阵调整成顺时针旋转90度的样子。
    + 要求：额外空间复杂度为O(1)
    + 思路：
        ```
        (1)我找到左上，左下，右上，右下，四个点，现将它们四个进行交换，然后找左上右面第一个，再找到对应的三个点，将它们四个在进行交换，然后直到把第一圈换完
        (2)将坐标变换，左上角向里圈移动一个，右下角向里圈移动一个，确定一个新的圈，在重复(1)，直到所有交换完毕
        比如：
            1  2  3  4 
            5  6  7  8 
            9  10 11 12 
            13 14 15 16 
        我先找到1, 4, 16, 13,将它们四个进行交换，
        然后来到下一位置，2, 8, 15, 9将它们四个也交换，
        然后......，直到将第一圈所有数交换完毕，
        来到里圈，6, 7, 11，10,将它们四个也交换，整 个图旋转完毕
        ```
    + 代码：
        ```
        package myP;
        public class RotateMatrix {
            /*整道题的思想一圈一圈转
            首先，第一圈，只需要转第一行中除了最后一个的所有数就可以了，也就是dR - tR - 1个数就可以了
            其次转多少圈：只要tR < dR那就一直转
            */
            public static void rotate(int [][] matrix){
                int tR = 0;//上x
                int tC = 0;//上y
                int dR = matrix.length - 1;//下x
                int dC = matrix[0].length - 1;//下y
                while(tC< dC){
                    rotateEdge(matrix, tR++, tC++, dR--, dC--);
                }
            }
            public static void rotateEdge(int[][] matrix, int tR, int tC, int dR, int dC){
                int times = dC - tC;
                int tmp = 0;
        //        i就是找 出发点
                for(int i = 0; i != times; i ++){
                    tmp = matrix[tR][tC + i];
                    matrix[tR][tC + i] = matrix[dR - i][tC];
                    matrix[dR - i][tC] = matrix[dR][dC- i];
                    matrix[dR][dC- i] = matrix[tR + i][dC];
                    matrix[tR + i][dC] = tmp;
                }
            }
            public static void printMatrix(int[][] matrix){
                for(int i = 0;i < matrix.length; i ++){
                    for(int j =0; j < matrix[i].length; j ++){
                        System.out.print(matrix[i][j] + " ");
                    }
                }
            }
            public static void main(String[] args){
                int[][] matrix = { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 },
                        { 13, 14, 15, 16 } };
                rotate(matrix);
                printMatrix(matrix);
            }
        }

        ```
8. 之”字形打印矩阵
    + 题目：给定一个矩阵matrix，按照“之”字形的方式打印这个矩阵，
        ```
            例如： 
            1  2  3  4 
            5  6  7  8 
            9  10 11 12
        “之”字形打印的结果为：1，2，5，9，6，3，4，7，10，11，8，12
        ```
    + 要求：额外空间复杂度为O(1)
    + 思路：
        ```
            设计两个点，A，B都在(0, 0)位置上，一个boolean型变量，确定打印方向，向下还是向上
            A的运动轨迹为每次向右移动，撞到最右了，向下移动
            B的运动轨迹为每次向下移动，撞到最下了，向右移动
            A，B各走各的，解耦的
        ```
    + 代码：
        ```
        package myP;

        public class ZigZagPrintMatrix {
            public static void printMatrixZigZag(int[][] matrix){
                /*两个点(A,B)的坐标，一个向右边走，一个向下走*/
                int aR = 0;
                int aC = 0;
                int bR = 0;
                int bC = 0;
                /*判断朝哪个方向走*/
                boolean fromUp = true;
                int endR = matrix.length - 1;
                int endC = matrix[0].length - 1;
                /*我只要没到最后一个点，我就一直走，两个点都走*/
                while(aR <= endR){
                    printLevel(matrix, aR, aC, bR, bC, fromUp);
                    //            如果A的列数来到最后一列，我才往下走，否则我不变
                    aR = aC == endC ? aR + 1 : aR;
        //            判断A是否到最后一行
                    aC = aC == endC ? aC : aC + 1;
                    bC = bR == endR ? bC + 1 : bC;
                    bR = bR == endR ? bR : bR + 1;
                    fromUp = !fromUp;
                }
            }
            public static void printLevel(int[][]matrix, int aR, int aC, int bR, int bC, boolean f){
        //        根据boolean类型不同，确定打印方向
                if(f){
                    while(bC != aC + 1){
                        System.out.print(matrix[bR--][bC++] + " ");
                    }
                }
                else{
                    while(aR != bR + 1){
                        System.out.print(matrix[aR++][aC--] + " ");
                    }
                }
            }
            public static void main(String[] args){
                int[][] Matrix = {{1, 2, 3, 4},{5, 6, 7, 8},{9, 10, 11, 12}};
                printMatrixZigZag(Matrix);
            }
        }

        ```
9. 在行列都排好序的矩阵中找数
    + 题目：给定一个有N*M的整型矩阵matrix和一个整数K，matrix的每一行和每一列都是排好序的。实现一个函数，判断K是否在matrix中。 
        ```
        例如： 
            1 3 5 6 
            2 5 7 9
            4 6 8 10 
        如果K为4，返回true；如果K为11，返回false。
        ```
    + 要求：时间复杂度为O(N+M)，额外空间复杂度为O(1)。
    + 思路：
    ```
    先从右上角找，右上角是6，说明6下面可能不会有4，
    因为这是个相对有序的数组，然后向左移动，来到5的位置，
    5比4大，所以5下面肯定也没有要找的数，然后来到3的位置，
    因为4比3大，所以，3左面的数被淘汰了，往下走，
    来到5, 5比4大，所以5下面的也都不用看，继续往左走......
    直到找到4
    ```
    + 代码
    + 重要概念：一道题最优解来自于题的数据状况，或者是它的问法
10. 打印两个有序链表的公共部分
    + 题目：给定两个有序链表的头指针head1和head2，打印两个链表的公共部分
    + 思路：和外排相似，重点就是merge
11. 判断一个链表是否为回文结构
    + 题目：给定一个链表的头节点head，请判断该链表是否为回文结构。 例如： 
        ```
        1->2->1，返回true。 
        1->2->2->1，返回true。
        15->6->15，返回true。 
        1->2->3，返回false。
        1->2->3->2->1 返回true。
        ```
    + 注意：
        链表问题，能够下功夫的就是额外空间，因为时间复杂度都差不多是O(N)，笔试中随意用，面试中，用额外空间复杂度为O(1)解决链表问题
    + 第一种思路：
        在遍历过程中把所有结点放入到栈中去，然后再遍历一遍，每遍历一个就从栈中拿出一个，每一步比对值都相等，那就是回文结构
    + 第二种思路
        和第一种差不多，就是我定义两个指针，快指针和慢指针，快指针一次走两步，慢指针一次走一步，快指针走完了，慢指针来到中点的位置上，然后将慢指针后面的数压栈，然后就是对比从栈里弹出的数，和原链表的数是否相等，其实空间省了一半，但是额外空间复杂度还是O(N)
    + 进阶： 如果链表长度为N，时间复杂度达到O(N)，额外空间复杂度达到O(1)。
    + 第三种思路：
    一个快指针，一个慢指针，快指针走完，慢指针走到中点的位置上(奇数正好在中点，偶数找到两个中点的前一个位置)，然后慢指针右半部分逆序,
    比如1->2->3->2->1，快指针走完，慢指针来到3的位置上，然后将3的next改了，指向null，2的next原来指向1，改为指向3，同理1指向2
    得到1->2->3<-2-<1(3指向null)，然后两个变量从左右两边的1开始，每次共同走一步，比对是否一样，走到终点位置停，得到true或者fasle，不过注意的是，走到终点之后，我要把指针改回去，改为原来的样子
    + 代码：
        ```
        package myP;
        import java.util.Stack;
        public class IsPalindromeList {
            public static class Node{
                public int value;
                public Node next;
                public Node(int data){
                    this.value = data;
                }
            }
            /*1.利用额外空间（空间复杂度为O(n)），将链表的全部数据压到栈里，然后从头节点开始和栈每次弹出的数进行比对，有不一样的，就返回false*/
            // need n extra space
            public static boolean isPalindrome1(Node head) {
                Stack<Node> stack = new Stack<Node>();
                Node cur =  head;
                while(cur != null){
                    stack.push(cur);
                    cur = cur.next;
                }
                while(head != null){
                    if(head.value != stack.pop().value){
                        return false;
                    }
                    head = head.next;
                }
                return true;
            }
            /*2.利用额外空间（空间复杂度为O(n)），用两个指针，快指针一次跑两个，慢指针一次一个，当快指针走到了结尾，慢指针走到中点的位置
            链表的后半部分数据压到栈里，然后从头节点开始和栈每次弹出的数进行比对，有不一样的，就返回false*/
            // need n/2 extra space
            public static boolean isPalindrome2(Node head) {
                if(head == null || head.next == null){
                    return true;
                }
                Node fast = head;//为什么视频上是fast = head.next ?
                Node cur = head;
                while(cur.next != null && cur.next.next != null){
                    fast = fast.next;
                    cur = cur.next.next;
                }
                Stack<Node> stack = new Stack<Node>();
                while(fast!= null){
                    stack.push(fast);
                    fast = fast.next;
                }
                while(!stack.isEmpty()){
                    if(head.value != stack.pop().value){
                        return false;
                    }
                    head = head.next;
                }
                return true;
            }
            public static boolean isPalindrome3(Node head){
                if(head == null || head.next == null){
                    return false;
                }
                Node n1 = head;//慢指针
                Node n2 = head;//快指针
                while (n2.next != null && n2.next.next != null) { // find mid node
                    n1 = n1.next; // n1 -> mid
                    n2 = n2.next.next; // n2 -> end
                }

                n2 = n1.next; //n2 = n1.next是差不多改变遍历的位置，要是n1.next = n2 那就是改变链表指针了
                n1.next = null;
                Node n3 = null;
                /*下面的while，就是将后半部分链表改变指针方向,执行完结果就是类似于1->2->3<-２<-1 */
                while (n2 != null) { // right part convert
                    n3 = n2.next; // n3 -> save next node
                    n2.next = n1; // next of right node convert
                    n1 = n2; // n1 move
                    n2 = n3; // n2 move
                }

                n3 = n1;/*将n1预先存在n3中，后面的归位要用到*/
                n2 = head;
                boolean res = true;
                while(n2 != null && n1 != null){
                    if(n1.value != n2.value){
                        res = false;
                        break;
                    }
                    n1 = n1.next;
                    n2 = n2.next;
                }

                /*下面的while，将链表后半部分指针归位，执行完结果就是1->2->3->2->1*/
                n1 = n3.next;
                n3.next = null;
                while(n1 != null){
                    n2 = n1.next;
                    n1.next = n3;
                    n3 = n1;
                    n1 = n2;
                }
                return res;
            }
            public static void printLinkedList(Node node) {
                System.out.print("Linked List: ");
                while (node != null) {
                    System.out.print(node.value + " ");
                    node = node.next;
                }
                System.out.println();
            }
            public static void main(String [] args){
                Node head = null;
                head = new Node(1);
                head.next = new Node(2);
                head.next.next = new Node(3);
                head.next.next.next = new Node(2);
                head.next.next.next.next = new Node(1);
                printLinkedList(head);
                System.out.print(isPalindrome1(head) + " | ");
                System.out.print(isPalindrome2(head) + " | ");
                System.out.print(isPalindrome3(head) + " | ");
                printLinkedList(head);
                System.out.println("=========================");
            }
        }

        ```
12. 将单向链表按某值划分成左边小、中间相等、右边大的形式
    + 题目：
        ```
        给定一个单向链表的头节点head，节点的值类型是整型，再给定一个
        整 数pivot。实现一个调整链表的函数，将链表调整为左部分都是值小于 pivot
        的节点，中间部分都是值等于pivot的节点，右部分都是值大于 pivot的节点。
        除这个要求外，对调整后的节点顺序没有更多的要求。 例如：链表9->0->4->5-
        >1，pivot=3。 调整后链表可以是1->0->4->9->5，也可以是0->1->9->5->4。总
        之，满 足左部分都是小于3的节点，中间部分都是等于3的节点（本例中这个部
        分为空），右部分都是大于3的节点即可。对某部分内部的节点顺序不做 要求
        ```
    + 思路：最快的方式就是找一个数组，里面存节点类型，然后借助荷兰国旗问题，重排，然后利用next都串起来，笔试中这么干
    + 缺点：
        - 第一：荷兰国旗不能实现稳定性
        - 第二：需要准备额外的辅助空间
    + 进阶：
    + 思路：
        ```
        这个题一定会传入两个参数，1是头结点，第二个是num
        准备三个变量less，equal，more，值都为null，类型是结点类型的引用类型
        一次遍历过程中，
        找到第一个小于num的结点，让less等于那个节点，
        找到第一个大于num的结点，让more等于那个节点，
        找到第一个等于equal的结点，让equal等于那个节点，
        如果小于或者大于或者等于的不存在，那就让对应的变量还为null
        再遍历一遍链表，如果发现小于num的，我看它是不是less，如果它是less，不用管，
        如果它不是less，让这个节点挂载less的next上，同理more和equal也这样做，
        然后让less的尾部和equal的头部相连，让equal的头部的more的尾部相连，整个链表就串好了
        扣边界，可能某个区域没结点，调用next会出错
        其实就相当于一个大链表分成三个小链表，然后三个链表首尾相连
        ```
    + 代码：
        ```
        03-SmallerEqualBigger
        ```
13. 复制含有随机指针节点的链表
    + 题目：一种特殊的链表节点类描述如下：
        ```
            public class Node { 
                public int value; 
                public Node next; 
                public Node rand;
                public Node(int data) { 
                    this.value = data; 
                }
            }
            Node类中的value是节点值，next指针和正常单链表中next指针的意义一样，都指向下一个节点，
            rand指针是Node类中新增的指针，这个指针可能指向链表中的任意一个节点，也可能指向null。 
            给定一个由Node节点类型组成的无环单链表的头节点head，
            请实现一个 函数完成这个链表中所有结构的复制，并返回复制的新链表的头节点。 
            比如：1->next->2->next->3->next->null
                 1-random->3，2->random->1，3->random->null
            这样一个链表的拷贝
        ```
    + 思路：
        ```
        利用hash表(需要额外空间复杂度为O(N))
        遍历节点，现将1-copy->1'，将1和1'放入哈希表中去，1是key，1'是value，
        然后利用1->next找到2，将2和2'也放入哈希表中去，同理，3也是
        然后我再遍历一下链表，我先找到1，通过key-value方式拿到1',此时1'的next和random指针都是null，
        因为1的next是可以找到2的，然后2通过哈希表找到2'，所以此时1'的next就可以设置为2'
        我可以通过1的random指针找到3，然后3通过哈希表找到3'，然后1'的random的指针就是3'
        此时1的next和random指针就都已经确定了,
        然后通过1->next->2,找到2，依次进行这样的操作，整个链表拷贝完毕

        ```
    + 补充hash表
        - 用法
            ```
                HashMap<String, Integer> map = new HashMap<>();
                map.put("A", 12);
                map.put("B", 13);
                map.put("c", 14);
                System.out.println(map.containsKey("A"));   //true
                System.out.println(map.get("A"));           //12
            ```
        - 特点： 不管是取数据，还是存数据，时间复杂度都是O(1)
    + 代码：
        ```
        03-copyListWithRand1
        ```
    + 进阶：不使用额外的数据结构，只用有限几个变量，且在时间复杂度为 O(N)内完成原问题要实现的函数
        - 思路：
            ```
            原本：
            1->next->2->next->3->next->null
            1-random->3，2->random->1，3->random->null
            现在
            1->next->1'->next->2->next->2'->next->3->next->3'->next->null
            我现在一次取出两个结点，1和1'，1->random->3，3->next->3'
            然后让1'->next->3'就完成了1'的next和random
            同理2和2'，3和3',最后将1'，2'，3'从大的链表里分离出来
            ```
    + 代码：
        ```
        03-copyListWithRand1
        ```
14. 两个单链表相交的一系列问题
    + 题目：
        ```
        在本题中，单链表可能有环，也可能无环。
        给定两个单链表的头节点 head1和head2，这两个链表可能相交，也可能不相交。
        请实现一个函数， 如果两个链表相交，请返回相交的第一个节点；
        如果不相交，返回null 即可。 
        ```
    + 思路：思考三个问题：
        ```
        1. 如何判断单链表有环还是无环：写一个函数实现，如果这个单链表有环，我返回第一个入环的节点，如果这个单链表无环，我返回空
            (1)实现
                1.1 我准备一个哈希表，然后从head1开始通过next指针的方式去遍历
                在遍历的过程中，把每一个节点都放入哈希map中去，
                下一次转回来的时候，我就可以查到，原来我这个结点之前加入过map，
                就能判断是否有环，第一个加入map的就是入环的结点
                1.2 如果不用哈希表怎么实现：
                    准备两个指针，一个是快指针，一个是慢指针
                    快指针一次走两步，慢指针一次走一步，
                    如果快指针在走的过程中遇到空了，那么这个链表必然没环
                    如果链表有环，快慢指针必然相遇，并且相遇后，快指针回到head1头节点位置上
                    然后快指针变为一次走一步，那么最后快指针和慢指针一定会在第一个入环节点处相遇，这是结论
            (2)注意：
                单链表一个结点只有一个next，所以不可能出现，先是一个环后来支出去一个尾巴的结构
            (3)准备loop1和loop2，记录两个单链表有环无环
        2. 怎么判断两个无环单链表第一个相交的节点(loop1 == null && loop2 == null)
            将链表1的所有结点都放在map中去，然后遍历链表2
            然后查链表2的结点在不在map中，第一个在的，就是第一个相交的结点
            如果链表2都遍历完了，都没有在map中的结点，那么两个链表不相交
        3. 怎么判断两个有环单链表第一个相交的节点(loop1 != null && loop2 != null)
        ```
    + 要求：如果链表1的长度为N，链表2的长度为M，时间复杂度请达到 O(N+M)，额外空间复杂度请达到O(1)。
